[
  {
    "objectID": "posts/conversational-agent-chatbot.html",
    "href": "posts/conversational-agent-chatbot.html",
    "title": "Build Conversational Agentic Chatbot",
    "section": "",
    "text": "Conversational Agentic Chatbots leveraging Large Language Models (LLMs) represent a significant leap in AI-powered communication. These advanced chatbots go beyond simple query responses, actively engaging in complex tasks and decision-making processes.\nThey can interact with databases to answer user questions, schedule appointments, or compose and send emails, to name but a few. Unlike traditional chatbots, these AI agents understand context, adapt to user needs in real time, and can perform actions autonomously.\nThe increasing importance of agentic chatbots in the AI world stems from their ability to provide more personalized, efficient, and human-like interactions.\nSome benefits include reduced workload for human teams, and the capacity to handle complex inquiries with greater accuracy and contextual awareness.\nAs businesses seek to enhance customer engagement and streamline operations, agentic chatbots powered by LLMs are becoming indispensable tools for delivering superior user experiences and driving operational efficiency",
    "crumbs": [
      "üìùPosts",
      "üí¨ **AI Chatbot**",
      "1. ü§ñ Build First Conversational Agentic Chatbot"
    ]
  },
  {
    "objectID": "posts/conversational-agent-chatbot.html#conversational-agentic-chatbot",
    "href": "posts/conversational-agent-chatbot.html#conversational-agentic-chatbot",
    "title": "Build Conversational Agentic Chatbot",
    "section": "Conversational Agentic Chatbot",
    "text": "Conversational Agentic Chatbot\nIn this guide, we‚Äôll explore the development of a conversational agentic chatbot through a real-world use case.\nOur objective is to create an LLM-powered chatbot capable of interacting with an unstructured database of food images and generating detailed descriptions of dishes presented in these images.\nFor instance:\nHuman: Can you describe images presented famous dishes?\nAI: Please provide the name or details of the image you would like me to describe.\nHuman: I think it is Figure 1\nAI: This image showcases a traditional Vietnamese B√°nh M√¨, a popular street food sandwich ...\nHuman: Now describe Figure 2\nAI: This dish is a classic Italian spaghetti with tomato sauce, ...\nOur technology stack for this project includes:\n\nLLM model: OpenAI‚Äôs GPT-4 or GPT-4-mini\nOrchestration framework: LangGraph & LangChain for creating and orchestrating the conversational agent-based chatbot\nUnstructured database: MongoDB for efficient storage and retrieval of image data\nLLM & prompt monitoring: Opik by Comet ML for performance tracking and artifact management\n\nNow, let‚Äôs dive into the exciting implementation phase of our project!",
    "crumbs": [
      "üìùPosts",
      "üí¨ **AI Chatbot**",
      "1. ü§ñ Build First Conversational Agentic Chatbot"
    ]
  },
  {
    "objectID": "posts/conversational-agent-chatbot.html#implementation-with-langgraph-openai-mongodb-opik-comet-ml",
    "href": "posts/conversational-agent-chatbot.html#implementation-with-langgraph-openai-mongodb-opik-comet-ml",
    "title": "Build Conversational Agentic Chatbot",
    "section": "Implementation with LangGraph, OpenAI, MongoDB, Opik (Comet ML)",
    "text": "Implementation with LangGraph, OpenAI, MongoDB, Opik (Comet ML)\n\nImporting packages & Loading environment variables\nFirst, we import necessary packages.\n# Import required packages\nimport os\nimport json\nimport requests\nimport opik\nfrom opik import track\nfrom langchain_core.messages import HumanMessage\nfrom langchain_openai import ChatOpenAI\nfrom langchain_core.tools import tool\nfrom langgraph.checkpoint.memory import MemorySaver\nfrom langgraph.prebuilt import create_react_agent\nfrom pymongo import MongoClient\nfrom IPython.display import Image, display\nfrom dotenv import load_dotenv\nNext, we need to load environment variables, such as API keys, to enable the use of various services. For example: OPENAI_API_KEY for accessing OpenAI GPT models, COMET_API_KEY for utilizing Comet ML‚Äôs Opik monitoring service, and CONNECTION_STRING for connecting to MongoDB.\n\n\n\nExample of .env file\n\n\nWe use the load_dotenv function from the dotenv package to securely load our confidential API keys.\nload_dotenv()\n\n\nConnect, Add and Query MongoDB\nLet‚Äôs first connect with your MongoDB cluster.\n# Get MongoDB Connection String, database name and collection name\nMONGO_CONNECTION_STRING = os.getenv('CONNECTION_STRING')\nFOOD_DATABASE_NAME = os.getenv('FOOD_DATABASE_NAME')\nFOOD_COLLECTION_NAME = os.getenv('FOOD_COLLECTION_NAME')\n\n# Connect to Mongo\nclient = MongoClient(MONGO_CONNECTION_STRING)\nfood_db = client[FOOD_DATABASE_NAME]\nfood_collection = food_db[FOOD_COLLECTION_NAME]\nImagine you have raw data in JSON format containing image names and their corresponding URLs. We load this data into a dictionary.\n\nGet the raw data\ndata_path = './data/food_db.json'\nwith open(data_path, 'r') as file:\n    food_dict = json.load(file)\nprint(food_dict)\nThe raw data is structured as follows:\n{'Figure 1': 'https://drive.usercontent.google.com/download?id=1ODozOIYAjChN_oZoSFxUqGaAlNMeKYya&export=view&authuser=0',\n 'Figure 2': 'https://drive.usercontent.google.com/download?id=1bxNoQ0ORvvA1Ywnijq3mCmlH4kp5Az96&export=view&authuser=0'}\n\n\nAdd item to Mongo DB\nNext, we insert each item from the above data dictionary into our food_photos data collection.\n# Iterate and upload to MongoDB\nfor image_name, image_uri in food_dict.items():\n    food_collection.insert_one({'image_name': image_name, 'image_uri': image_uri})\n\n\n\nFood Photo DB on MongoDB\n\n\n\n\nQuery an item from Mongo DB\nThe following example demonstrates how to retrieve an image URI from our MongoDB collection using an image name, and then display the image.\nimport requests\nfrom IPython.display import Image, display\n\n# Querying image_uri by image_name\nimage_name = \"Figure 1\"\nitem = food_collection.find_one({'image_name': image_name})\nimage_url = item['image_uri']\n\n# Plot image\nresponse = requests.get(image_url)\nimage_data = response.content\ndisplay(Image(data=image_data))\n\n\n\nExample of querying image_uri\n\n\n\n\n\nCreate OpenAI LLM and Opik clients\nIn the next step, we initialize the OpenAI LLM model and the Opik client, which serve as the core AI model and the AI monitoring service, respectively.\n# Initial OpenAI model, i.e. gpt-4o or gpt-4o-mini\nllm = ChatOpenAI(model=\"gpt-4o\")\n\n# Initiate Opik client for LLM and prompt monitoring and management\nopik_client = opik.Opik()\n\n\nPromp tracking and management with Opik (Comet ML)\nPrompt engineering significantly impacts LLM performance. Therefore, a dedicated tool for prompt monitoring, versioning, and management is crucial. This practice is a cornerstone of LLMOps best practices. A centralized platform is essential for streamlining prompt monitoring and management while enabling seamless team collaboration.\nFor this vital task, we utilize Comet ML‚Äôs Opik to ensure easy-to-use and effectiveness.\nLet‚Äôs create our prompt for the agent task on the Opik platform. Alternatively, you can also create it programmatically. See this tutorial from Opik for more information. \nThe prompt for our agent is as bellow.\nYou are a renowned master chef with expertise in analyzing dishes and crafting exquisite recipes. \n\nUpon receiving a photo of a food item, you will provide a detailed description of the dish, including its key characteristics, ingredients, and cultural context if applicable. \n\nThen, you will create a high-quality, easy-to-follow recipe to prepare this dish, ensuring both flavor and presentation are exceptional.\nWhen you create different prompts for various purposes, the Opik‚Äôs Prompt Library page should look like this: \n\n\nPrepare prompt for AI Tool\nAfter creating the agent prompt on the Opik platform, we use the Opik Python SDK to retrieve this prompt directly in our source code. We then integrate it into a HumanMessage template from LangChain, enabling its use in the main function of our agentic tool.\nThe prompt and human message preparation are achieved using the following get_prompt function.\nWe use a decorator for this function:\n\n@track: for Opik to track the function‚Äôs inputs and outputs.\n\n@track\ndef get_prompt(prompt_name, image_url):\n    # Get prompt that is created on Opik platform\n    prompt_template = opik_client.get_prompt(name=prompt_name)\n    formatted_prompt_template = prompt_template.format()\n\n    # Create Human message\n    human_message = HumanMessage(\n        content=[\n            {\"type\": \"text\", \"text\": formatted_prompt_template},\n            {\"type\": \"image_url\", \"image_url\": {\"url\": image_url}},\n        ],\n    )\n    return human_message\nNext, we create the main function, generate_ip_image_description, for our agentic tool. Following the LangGraph agent convention, we include a docstring that describes the task the agent should perform. This function performs several steps:\n\nSpecify the name of the prompt we want to use.\nQuery the image_url from the MongoDB collection using the image_name.\nCreate a human message using the get_prompt function with two input arguments: prompt_name and image_url.\nInvoke the LLM model with the message to generate the response as the image description.\n\nWe apply two decorators to this function:\n\n@tool from LangChain_Core to define this function as an agentic tool.\n@track for Opik to enable tracking of inputs and outputs.\n\n\n\nCreate main function for agentic tool\n@tool\n@track\ndef generate_ip_image_description(image_name):\n    \"\"\"Generate description for an image about food. \n    Call this whenever you need to provide an image description, \n    for example when a customer asks 'Can you describe the Figure 1?'\"\"\"\n    \n    # prompt_name in created Opik prompt library\n    prompt_name = \"food_image_description\"\n\n    # get image_url from mongodb based on image_name\n    item = food_collection.find_one({'image_name': image_name})\n    image_url = item['image_uri']\n\n    # Get human message\n    message = get_prompt(prompt_name, image_url)\n\n    # Get image description from llm\n    response = llm.invoke([message])\n    return response.content\n\n\nAgent {Tools + Prompt + LLM + Memory}\nOnce the tools, LLM, and prompt are ready, we combine these agent components using the create_react_agent function from LangGraph to build our LLM agent. Importantly, to enable our agent chatbot to handle conversations effectively, we integrate memory by using MemorySaver from LangGraph.\n# Use`generate_ip_image_description` as tools for function calling\ntools = [generate_ip_image_description]\n\n# Global prompt for agent\nprompt = (\n    \"You are a helpful assistant. \"\n    \"You may not need to use tools for every query - the user may just want to chat!\"\n)\n\n# Agent memory\nmemory = MemorySaver()\n\n# Create Agent\nagent = create_react_agent(llm, tools, state_modifier=prompt, checkpointer=memory)",
    "crumbs": [
      "üìùPosts",
      "üí¨ **AI Chatbot**",
      "1. ü§ñ Build First Conversational Agentic Chatbot"
    ]
  },
  {
    "objectID": "posts/conversational-agent-chatbot.html#agent-inference",
    "href": "posts/conversational-agent-chatbot.html#agent-inference",
    "title": "Build Conversational Agentic Chatbot",
    "section": "Agent Inference",
    "text": "Agent Inference\nNow, let‚Äôs move on to the final and exciting step: testing our conversational agentic chatbot.\nBefore testing, we need to create the agent_inference function, which performs two key tasks:\n\nInvoke the agent‚Äôs invoke method using the user‚Äôs query.\nRetrieve the desired answer, handling two possible scenarios:\n\nIf no ToolMessage is returned, retrieve the AIMessage content to guide the user in providing more information.\nIf a ToolMessage is returned, extract and return its content.\n\n\ndef agent_inference(query):\n    # Response \n    response = agent.invoke(\n        {\"messages\": [HumanMessage(query)]},\n        config={\"configurable\": {\"thread_id\": \"1\"}},\n    )\n    \n    # Get ToolMessage if exists, else get AIMessage\n    if response['messages'][-2].__class__.__name__ != 'ToolMessage':\n        return response['messages'][-1].content # AIMessage content\n    else:\n        return response['messages'][-2].content # ToolMessage content\nNow, let‚Äôs test our conversational agentic chatbot with three scenarios:\n\nQA #1: The user asks a general question about describing an image. The chatbot responds by requesting more specific information.\nQA #2: The user specifies the image name (e.g., ‚ÄúFigure 1‚Äù), and the chatbot generates a description for this image.\nQA #3: The user asks about a new image (e.g., ‚ÄúFigure 2‚Äù), and the chatbot processes the request and generates a description for the new image.\n\n\nQA #1\n# Question-Response 1\nquery = \"Can you describe for me an image?\"\nresponse = agent_inference(query)\nprint(response)\nOf course! Please provide me with the image name or more details, so I can generate a description for you.\n\n\nQA #2\n# Question-Response 2\nquery = \"I think it is Figure 1\"\nresponse = agent_inference(query)\nprint(response)\n\n\n\nFigure 1: Vietnamese Sandwich\n\n\nThis image showcases a B√°nh M√¨, a popular Vietnamese sandwich known for its delightful combination of flavors and textures. The B√°nh M√¨ is a fusion of French and Vietnamese culinary traditions, originating from the period of French colonial rule in Vietnam. It typically features a crusty baguette filled with a variety of ingredients that create a harmonious balance of savory, spicy, sweet, and tangy flavors.\n\n### Key Characteristics:\n- **Bread:** A light, crispy baguette with a soft interior.\n- **Protein:** Often includes grilled or roasted meats such as pork or chicken.\n- **Vegetables:** Fresh cucumber slices, pickled carrots, and daikon radish.\n- **Herbs:** Fresh cilantro adds a fragrant note.\n- **Condiments:** Mayonnaise, p√¢t√©, and a hint of spicy chili.\n\n### Recipe for a Classic B√°nh M√¨\n\n#### Ingredients:\n- **Baguette:**\n    - 1 fresh baguette\n\n- **Protein:**\n    - 200g pork tenderloin or chicken breast\n    - 2 tablespoons soy sauce\n    - 1 tablespoon fish sauce\n    - 1 tablespoon sugar\n    - 1 garlic clove, minced\n    - 1 tablespoon vegetable oil\n\n- **Pickled Vegetables:**\n    - 1 carrot, julienned\n    - 1 daikon radish, julienned\n    - 1/4 cup white vinegar\n    - 1/4 cup sugar\n    - 1/2 cup water\n    - Pinch of salt\n\n- **Additional Toppings:**\n    - 1 cucumber, thinly sliced\n    - Fresh cilantro leaves\n    - 2 tablespoons mayonnaise\n    - Fresh chili slices (optional)\n\n#### Instructions:\n\n1. **Marinate the Protein:**\n    - In a bowl, combine soy sauce, fish sauce, sugar, garlic, and oil. Add the pork or chicken, ensuring it's well-coated. Marinate for at least 30 minutes.\n\n2. **Prepare Pickled Vegetables:**\n    - In a small saucepan, combine vinegar, sugar, water, and salt. Heat until sugar dissolves, then let cool.\n    - Place carrot and daikon in a jar, pour the pickling liquid over, and let sit for at least 30 minutes.\n\n3. **Cook the Protein:**\n    - Heat a grill pan or skillet over medium-high heat. Cook the marinated meat until it's cooked through and slightly caramelized. Let rest, then slice thinly.\n\n4. **Assemble the B√°nh M√¨:**\n    - Slice the baguette lengthwise, spread mayonnaise on both sides.\n    - Layer the cooked protein, pickled vegetables, cucumber slices, cilantro, and chili (if using) inside the baguette.\n\n5. **Serve:**\n    - Press the sandwich slightly to hold it together, and serve immediately to enjoy the contrasting textures and flavors.\n\nThis B√°nh M√¨ recipe offers a delightful balance of flavors and can be customized with your preferred proteins and additional toppings. Enjoy this Vietnamese classic as a flavorful and satisfying meal.\n\n\nQA #3\n# Question-Response 3\nquery = \"Now describe Figure 2\"\nresponse = agent_inference(query)\nprint(response)\n\n\n\nFigure 2: Italian Spaghetti\n\n\nThis dish is a classic Italian Spaghetti al Pomodoro. It features a beautifully arranged mound of spaghetti topped with a rich tomato sauce, adorned with fresh basil leaves and a sprinkle of grated Parmesan cheese. The vibrant red of the sauce contrasts with the golden pasta, and the garnishing adds a touch of green, making it visually appealing.\n\n### Key Characteristics and Cultural Context:\n- **Main Ingredients**: Spaghetti, tomatoes, basil, Parmesan cheese.\n- **Cultural Context**: Spaghetti al Pomodoro is a staple in Italian cuisine, celebrated for its simplicity and fresh ingredients. It embodies the Italian philosophy of letting high-quality ingredients shine without overwhelming them.\n\n### Recipe for Spaghetti al Pomodoro\n\n#### Ingredients:\n- 400g spaghetti\n- 800g ripe tomatoes (or canned whole tomatoes)\n- 3 tablespoons olive oil\n- 3 cloves garlic, minced\n- Salt and freshly ground black pepper to taste\n- A pinch of red pepper flakes (optional)\n- Fresh basil leaves\n- 100g Parmesan cheese, grated\n\n#### Instructions:\n\n1. **Prepare the Tomatoes:**\n    - If using fresh tomatoes, blanch them in boiling water for 30 seconds, then transfer to ice water. Peel and chop them.\n\n2. **Cook the Pasta:**\n    - Bring a large pot of salted water to a boil. Add the spaghetti and cook according to package instructions until al dente. Reserve 1 cup of pasta water, then drain the pasta.\n\n3. **Make the Sauce:**\n    - In a large skillet, heat the olive oil over medium heat. Add the minced garlic and saut√© until fragrant, about 1 minute.\n    - Add the tomatoes (fresh or canned) and crush them with a spoon. Season with salt, black pepper, and red pepper flakes if using.\n    - Simmer the sauce for about 15 minutes, stirring occasionally. Adjust the seasoning as needed.\n\n4. **Combine Pasta and Sauce:**\n    - Add the cooked spaghetti to the sauce. Toss to coat the pasta, adding reserved pasta water if the sauce is too thick.\n\n5. **Serve:**\n    - Divide the pasta among serving plates. Top with grated Parmesan cheese and fresh basil leaves.\n    - Drizzle a little olive oil over the top for extra flavor.\n\n### Presentation Tips:\n- Use a fork to twist the pasta into nests on each plate.\n- Place basil leaves strategically for a pop of color.\n- Serve with extra Parmesan cheese on the side.\n\nEnjoy your homemade Spaghetti al Pomodoro with a glass of red wine for an authentic Italian dining experience!\nGreat! Amazing! Our conversational agentic chatbot has successfully provided descriptions for each photo we requested!",
    "crumbs": [
      "üìùPosts",
      "üí¨ **AI Chatbot**",
      "1. ü§ñ Build First Conversational Agentic Chatbot"
    ]
  },
  {
    "objectID": "posts/conversational-agent-chatbot.html#monitoring-qa-prompt-execution-time",
    "href": "posts/conversational-agent-chatbot.html#monitoring-qa-prompt-execution-time",
    "title": "Build Conversational Agentic Chatbot",
    "section": "Monitoring QA, Prompt, Execution Time",
    "text": "Monitoring QA, Prompt, Execution Time\nAs discussed earlier, monitoring prompts and the LLM‚Äôs inputs and outputs is crucial for enhancing traceability, which helps us analyze the performance of the LLM agent effectively.\nOpik platform ensures tracking for each query, including:\n\nThe prompt used.\nInputs and outputs for each function, sub-function, and agent tool.\nExecution time for each step and function.\n\n\nMonitoring QA #1\n\n\n\nQA tracking #1 on Opik platform\n\n\n\n\nMonitoring QA #2\n\n\n\nQA tracking #2 on Opik platform\n\n\n\n\nMonitoring QA #3\n\n\n\nQA tracking #3 on Opik platform\n\n\nWhen numerous experiments are conducted, analyzing these tracked data points can help us optimize the system effectively.",
    "crumbs": [
      "üìùPosts",
      "üí¨ **AI Chatbot**",
      "1. ü§ñ Build First Conversational Agentic Chatbot"
    ]
  },
  {
    "objectID": "posts/conversational-agent-chatbot.html#conclusion",
    "href": "posts/conversational-agent-chatbot.html#conclusion",
    "title": "Build Conversational Agentic Chatbot",
    "section": "Conclusion",
    "text": "Conclusion\nIn summary, Conversational Agentic Chatbots leveraging Large Language Models (LLMs) are innovating AI-driven interactions by combining contextual understanding, adaptability, and autonomous decision-making.\nAs demonstrated in the development of a food image description chatbot, these systems can seamlessly integrate with unstructured databases like MongoDB, advanced LLM like OpenAI GPT-4o, advanced orchestration frameworks like LangGraph, and monitoring tools like Comet ML‚Äôs Opik to deliver highly personalized and context-aware user experiences.\nBy enabling enhanced customer engagement, streamlined operations, and creative problem-solving, agentic chatbots are transforming industries and setting new standards for intelligent communication tools. As businesses increasingly adopt this cutting-edge technology, the potential for innovation and efficiency in human-AI collaboration continues to grow.",
    "crumbs": [
      "üìùPosts",
      "üí¨ **AI Chatbot**",
      "1. ü§ñ Build First Conversational Agentic Chatbot"
    ]
  },
  {
    "objectID": "posts/conversational-agent-chatbot.html#reference",
    "href": "posts/conversational-agent-chatbot.html#reference",
    "title": "Build Conversational Agentic Chatbot",
    "section": "Reference",
    "text": "Reference\n[1] https://cookbook.openai.com/examples/how_to_use_guardrails\n[2] https://medium.com/velotio-perspectives/an-introduction-to-asynchronous-programming-in-python-af0189a88bbb\n[3] https://realpython.com/solid-principles-python/",
    "crumbs": [
      "üìùPosts",
      "üí¨ **AI Chatbot**",
      "1. ü§ñ Build First Conversational Agentic Chatbot"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Hi, I‚Äôm Quang. I am an AI/ML engineer. I live and work in Paris, France."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "‚ú® AI/ML, MLOps, LLMOps",
    "section": "",
    "text": "Build Conversational Agentic Chatbot\n\n\nBuilding conversational chatbot using agent (tool/function calling) to interact with database\n\n\n\nAgentic Chatbot\n\n\nConversational Chatbot\n\n\nFunction Calling\n\n\n\n\n\n\nNov 23, 2024\n\n\n14 min\n\n\n\n\n\n\n\n\n\nNo matching items"
  }
]